---
tags:
  - PostGIS
  - Prisma
  - SQL
  - WEB
  - Backend
  - Интересное
  - Программирование
  - PostgreSQL
Authors:
  - Naylour
isDone: false
createdAt: 2025-09-03
---

## Введение

Всем привет. Сегодня я расскажу вам о своём опыте реализации фильтрации заведений по: расстоянию до пользователя, диапазону расстояний и диапазону оценки; и сортировке по имени, оценке и расстоянию.

База данных [PostgreSQL](https://www.postgresql.org/), работа с базой происходит через [Prisma](https://www.prisma.io/docs/orm), используется также расширение [PostGIS](https://postgis.net/) для PostgreSQL

## Коротко про каждого из них 

**PostgreSQL**:
- Реляционная база данных.
- Открытый исходный код, очень мощная и расширяемая.
- Поддерживает транзакции, индексы, хранимые процедуры, JSON, full-text search.
- Часто используется как основная БД в веб-проектах.
- Им пользуются более чем [48.7% индустрии](https://www.enterprisedb.com/blog/postgres-developers-favorite-database-2024?utm_source=chatgpt.com)
- О нём я расскажу [[PostgreSQL. Лучшая база данных(по моему мнению)|здесь]]

---

**PostGIS**:
- Расширение к PostgreSQL для работы с геоданными (GIS).
- Добавляет типы `geometry`, `geography` (точки, линии, полигоны и т. д.).
- Дает функции для:
    - поиска ближайших объектов,
    - вычисления расстояний и площадей,
    - пересечения и объединения геометрий.
- Стандарт в геоинформационных системах.
- О нём я расскажу [[Немного про PostGIS|здесь]]

---

**Prisma**:
- `ORM` (Object-Relational Mapping) для `TypeScript/JavaScript`.
- Позволяет работать с БД через удобный API вместо “чистого SQL”.
- Поддерживает PostgreSQL, MySQL, SQLite, MongoDB и др.
- Основные плюсы: типобезопасность, автогенерация моделей по схеме, миграции.
- Хорошо работает в стеке `Node.js / Bun`, особенно в fullstack-проектах.
- О нём я расскажу [[Prisma ORM. Почему же эта лучшая ORM для JavaScript проектов?|здесь]]

## Модели

Для примера я использовал обрезанную версию базы данных, которая используется в одном из моих разработок.

![[Модель базы данных с адресом заведения.png|Модель базы данных с адресом заведения]]


#### City

Город, хранит в себе название города и его идентификатор в нашей системе. В нём находятся [[#Venue|заведения]] и пользователи.p

Имеет следующую структуру:
- Идентификатор в нашей системе - `VARCHAR(36) PRIMARY KEY`
- Название - `TEXT`

---
#### Venue

Заведение, представляет из себя сущность, которая хранит в себе данные по какому-либо заведению в [[#City|городе]]:
- Идентификатор в нашей системе - `VARCHAR(36) PRIMARY KEY`
- Логотип - `TEXT`
- Название - `TEXT`
- Среднюю оценку - `FLOAT`
- [[#VenueInCity|Идентификатор города]] - `VARCHAR(36)`

---
#### VenuePhoto

Фотография заведения. Хранит в себе:
- Идентификатор в нашей системе - `VARCHAR(36) PRIMARY KEY`
- Ссылка на изображение - `TEXT`
- Порядок в списке - `SMALLINT`
- Показывать ли его в карточке заведения - `BOOLEAN`
- Идентификатор заведения - `VARCHAR(36)`

---
#### VenueInCity

Представляет из себя сущность, которая связывает заведение с его городом. Это можно было сделать и без него, но основная база данных в проекте была устроена таки образом, что она выполняет другие данные ей задачи и в целях `нормализации` и `декомпозиции сущностей` пришлось эти данные выносить в отдельную таблицу.

Он связан с [[#City|городом]] связью `One-to-Many(Один ко многим)` один город, в котором много [[#VenueInCity|заведений]], и со своим [[#Venue|заведением]] связью `One-to-One(Один к одному)` заведение может существовать только в одном [[#City|месте]].

Его структура:
- Идентификатор в нашей системе - `VARCHAR(36) PRIMARY KEY`
- Идентификатор города - `VARCHAR(36)`
- Идентификатор заведения - `VARCHAR(36)`

---
#### Address

Хранит в себе точку на корте в формате `широта:долгота` типа [[Немного про PostGIS#Про тип POINT|POINT(PostGIS)]].

Структура:
- Идентификатор в нашей системе - `VARCHAR(36) PRIMARY KEY`
- point - `POINT`
- [[#VenueInCity|Идентификатор заведения]] - `VARCHAR(36)`

Надеюсь, чуть понятна структура, особенно про [[#VenueInCity|VenueInCity]]. Если же нет, то просто ещё раз перечитайте, эта сущность представляет из себя абстрактное существование заведения в городе.

## Пишем SQL

**Вот так выглядит один из запросов, которые мы будем писать**

```SQL
-- SQL
SELECT 
	v.id,
	v.logo,
	v.name,
	COALESCE(vp.photos, '[]') AS photos,
	v.average_estimation, 
	addr.distance AS "distance" 
FROM public."Venue" v 

LEFT JOIN LATERAL ( 
	SELECT json_agg(vp.href) AS photos 
	FROM public."VenuePhoto" vp 
	WHERE vp.venue_id = v.id 
) vp ON true

LEFT JOIN LATERAL ( 
	SELECT MIN( 
		ST_Distance( 
			ST_SetSRID(ST_MakePoint(44.606683, 40.105852), 4326)::geography,
			a.point::geography
		) 
	) AS distance 
	FROM public."VenueInCity" vic 
	JOIN public."Addresse" a ON a.venue_id = vic.id 
	WHERE vic.venue_id = v.id 
) addr ON true

 ORDER BY 
	 addr.distance IS NULL, 
	 addr.distance ASC
;
```

Я предполагаю что с основами SQL вы уже знакомы, и мы можем на этом не останавливаться. В любом случае, вот парочка ресурсов где можно легко это сделать:
- Пошаговый курс от **W3Schools** - [ссылка](https://www.w3schools.com/sql/default.asp)
- Курс по SQL в Stepik "**Интерактивный тренажер по SQL**" - [ссылка](https://stepik.org/course/63054/promo)
- Если вы немного знаете, но не хватает практики - [ссылка](https://leetcode.com/problemset/database)

И так, поехали.

### Фильтрация по средней оценке

Наши заведения имеют поле `average_estimation` типа `SMALLINT`, это число `-32768...32767`, но в нашем случае от 1 до 5. Наш запрос должен учитывать что это поле может быть равна `NULL`. Почему `NULL`? Потому что `0` - это число, а `NULL` отсутствие значения, что логично, у заведения ведь оценок может и не быть. Так же, сортировку по `уменьшению/увеличению`, а также диапазон самой оценки. 

Выглядеть всё будет так
```SQL
SELECT 
	v.id,
	v.logo,
	v.name,
	COALESCE(vp.photos, '[]') AS photos,
	v.average_estimation,
	 
	-- addr.distance AS "distance"
	NULL::numeric as "distance"
FROM public."Venue" v 

LEFT JOIN LATERAL ( 
	SELECT json_agg(vp.href) AS photos 
	FROM public."VenuePhoto" vp 
	WHERE vp.venue_id = v.id 
) vp ON true

-- LEFT JOIN LATERAL ( 
--	SELECT MIN( 
--		ST_Distance( 
--			ST_SetSRID(ST_MakePoint(44.606683, 40.105852), 4326)::geography,
--			a.point::geography
--		) 
--	) AS distance 
--	FROM public."VenueInCity" vic 
--	JOIN public."Addresse" a ON a.venue_id = vic.id 
--	WHERE vic.venue_id = v.id 
--) addr ON true

WHERE
    v.average_estimation IS NOT NULL AND 
    v.average_estimation BETWEEN 1 AND 5 -- От и до
ORDER BY 
	 v.average_estimation ASC -- По возрастанию, DESC - по убыванию
;
```

